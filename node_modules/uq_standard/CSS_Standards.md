# The University of Queensland #

## CSS Guidelines for Developers ##

***

| Version       | Date     | Author            | Notes                     |
| ------------- |----------|:----------------- |:------------------------- |
| Source        | 11 March 2015 | Drupal Community  | Fork [Drupal 8 CSS architecture](https://www.drupal.org/node/1887918) guidelines. |
| First draft   | 27 April 2015 | Graham Arrowsmith | Add component markup, examples, sources. |
| Revised       | 7 August 2018 | David Pollitt     | Remove & update unfinished / incorrect examples. Add linting. |



### Contents ###

1. **[Principles](#principles)**
  * [Goals](#goals)
2. **[Common CSS pitfalls](#css-pitfalls)**
  * [Modifying components based on context](#css-pitfalls_1)
  * [Relying on a specific HTML structure](#css-pitfalls_2)
  * [Overly generic class names](#css-pitfalls_3)
  * [Making a rule do too much](#css-pitfalls_4)
  * [Needing to undo styles](#css-pitfalls_5)
3. **[Best Practices](#best-practices)**
  1. [Avoid reliance on HTML structure](#best-practices_1)
  2. [Define component elements](#best-practices_2) 
  3. [Extend components using modifier classes](#best-practices_3)
  4. [Separation of concerns](#best-practices_4)
   * [CSS Frameworks](#css-frameworks)
  5. [Name Components using design semantics](#best-practices_5)
  6. [Formatting class names](#best-practices_6)
4. **[Components](#components)**
  1. [Component markup](#component-markup)
  2. [Component template](#component-template)
5. **[File structure](#file-structure)**
6. [Linting](#linting)
7. [Acknowledgements](#acknowledgements)
7. [Tools](#tools)
8. [Notes](#notes)
 * [Frameworks](#note-frameworks)
 * [File size](#note-file-size)

***

## <a name="principles"></a>Principles ##

The following principles are derived from SMACSS, BEM, Drupal 8 CSS standards, 
and guided by several leading developers including John Albin and founded on 
the architectural principles established by Nicholas Gallagher to manage a 
large codebase distributed to many developers. See 
[Acknowledgements](#acknowledgements) for a full list of sources.
 
## <a name="goals"></a>Goals ##

This styleguide, when well followed, will:

* set the standard for code quality across our codebases;
* promote consistency across codebases;
* give developers a feeling of familiarity;
* increase productivity.

The goals of good CSS, like any programming language should follow the 
following best practices:

### <a name="goals_1"></a>1. Predictable, reusable and maintainable ###

> **Give each class just one reason to change; and 
> “Reason to change” == “responsibility”. For example: box or card class does 
> not have a  responsibility to change the colour.**
> 
> &mdash; Single Responsibility Principle (SRP)

> **CSS rules should be abstract and decoupled enough that you can build new 
> components quickly from existing parts without having to recode patterns and 
> problems you’ve already solved.**
> 
> &mdash; Philip Walton, CSS Architecture

As new components and features are needed, it should be easy to add, modify and 
extend CSS without breaking (or refactoring) existing styles.

### <a name="goals_2"></a>2. Legible and meaningful ###

> **Class names should communicate useful information to developers.**
> 
> – Nicolas Gallagher, About HTML Semantics and Front-End Architecture

### <a name="goals_3"></a>3. Scalable ###

CSS should be easy to manage for a single developer or for large, distributed 
teams.

***

## <a name="css-pitfalls"></a>Common CSS pitfalls ##

> Before we look at ways to achieve the goals of good CSS architecture, I think 
> it can be helpful to look at common practices that get in the way of our 
> goals. It’s often only through repeated mistakes that we can begin to embrace 
> an alternate path.
>
>The following examples are all generalizations of code I’ve actually written, 
> and, while technically valid, each has lead to disaster and headache. Dispite 
> my best intentions and the promise that this time would be different, these 
> patterns consistently got me into trouble.
>
> Source: [Philip Walton's CSS Architecture](http://philipwalton.com/articles/css-architecture)

### <a name="#css-pitfalls_1"></a>**Pitfall:** Modifying components based on context ###

    /* Modifying a component when it’s in a sidebar. */
    .sidebar .component {}
 
This may seem natural, but actually makes CSS less predictable and 
maintainable. Sooner or later you’re going to need that component style 
somewhere other than a sidebar! Or, the reverse may happen: a new developer 
places a component in the sidebar and gets an unexpectedly different appearance.

### <a name="#css-pitfalls_2"></a>**Pitfall:** Relying on specific HTML structure ####

Mirroring a markup structure in our CSS selectors makes the resulting styles 
easy to break (with markup changes) and hard to reuse (because it’s tied to 
very specific HTML). 

This pitfall comes in several forms:

* Overly complex selectors: `.nav > ul > li > a`, `article p:first-child`
* Qualified selectors: `a.button`, `ul.nav`
 
### <a name="#css-pitfalls_3"></a>**Pitfall:** Overly generic class names ###

Similar to the pitfall of styling a component based on context, it’s common to 
‘scope’ a component’s parts under the parent component using a descendant 
selector:

    /* Bad */
    .widget { }
    .widget .title { }
    #sidebar .widget { }

    /* Good */
    .widget { }
    .widget-sidebar { }
    .widget-title { }

This CSS might seem economical, but tends to be counterproductive: `.title` and 
`.content` are too generic. A stand-alone `.title` component created later will 
affect widget titles, likely without intending to.

Tying your class name semantics tightly to the nature of the content has 
already reduced the ability of your architecture to scale or be easily put to 
use by other developers.

That is to say, we should use sensible names—classes like `.border` or `.red` 
are never advisable—but we should avoid using classes which describe the exact 
nature of the content and/or its use cases. Using a class name to describe 
content is redundant because content describes itself.

### <a name="#css-pitfalls_4"></a>**Pitfall:** Making a rule do too much ###

Applying positioning, margins, padding, colors, borders and text styles all in 
a single rule overloads the rule, making it difficult or impossible to reuse if 
some parts (say, background, borders and padding) need to be applied to a 
similar component later on.

### <a name="#css-pitfalls_5"></a>**Pitfall:** Needing to undo styles ###

Creating style rules that undo other rules, like `.component-no-padding` makes 
CSS over-complex, hard to understand and maintain, and bloats the stylesheet. 
Needing such styles usually indicates that some existing rules are doing too 
much.

`!important` does have a place in CSS projects, but only if used sparingly and 
proactively.

Proactive use of `!important` is when it is used before you’ve encountered any 
specificity problems; when it is used as a guarantee rather than as a fix. 
There are times when you know you will always, always want a style to take 
precedence, and you will know this up front.

***

## Components ##

Components are the discrete, purpose-built visual elements that make up the UI 
of a site or app. Components consist of HTML, CSS, and often – but not always – 
JavaScript. They are our navbars, dialogs, buttons and carousels. Components 
can be simple (such as icon containers and buttons) or complex enough to be 
themselves composed of other components.

## <a name="best-practices"></a>Best Practices ##

### <a name="best-practices_1"></a>1. Avoid reliance on HTML structure ###

* CSS should define the appearance of an element anywhere and everywhere it appears.
* Use classes to assign appearance to markup. 
* Never use id selectors in CSS.
* Keep selectors short. The best selector is a single class or element.
* Sometimes multi-part selectors are pragmatic. e.g. sibling selectors that inject rules or padding.

However, extra care should be taken when using multi-part selectors:

* Avoid elements with no native semantics (`div`, `span`) in multi-part selectors.
* Avoid the descendent selector (e.g. `.my-list li`) where possible, especially for components that may wrap other components. The descendant selector has a habit of unintentionally affecting nested elements. Prefer the child selector: `.my-list > li`.
* Avoid more than 2 combinators in a selector. The following rule is maxed out: `.my-list > li > a`.
* If in doubt, add a class and style the element directly.

### <a name="best-practices_2"></a>2. Define component elements using their own classes ###

To avoid relying on markup structure and overly-generic class names, define a 
component’s elements explicitly, prefixing them with the component’s name 
followed by two underscores:

    .component {}
        /* Component elements */
        .component__header {}
        .component__body {}

**Note** there is no need to reflect DOM structure in the class name; for 
example, do not replace `.menu li a` with `.menu__item__link`. The class 
`.menu__link` should be sufficiently specific.

### <a name="best-practices_3"></a>3. Extend components using modifier classes ###

Create component variants explicitly, adding a suffix with the variant name 
preceded by two dashes. In order to keep the stylesheet DRY, this modifier 
class should only contain the styles needed to extend the original. This means 
that both base and modifier classes must appear together in the markup:

#### CSS ####

    /* Button component */
    .button {
        /* styles */
    }
    
    /* Button modifier class */
    .button--primary {
        /* modifications and additions */
    }

#### HTML ####

    <!-- Button variant is created by applying both component and modifier classes -->
    <button class="button button--primary">Save</button>

### <a name="best-practices_4"></a>4. Separation of concerns ###

Components should not be responsible for their positioning or layout within the 
site. Never apply widths or heights, except to elements that natively have 
these properties (e.g. images). Within components, separate structural rules 
from stylistic rules.

> The idea here is to focus fully on one thing at once; build one thing to do 
> its job very well whilst paying as little attention as possible to other 
> facets of your code. Once you have addressed and built all these separate 
> concerns in isolation—meaning they’re probably very modular, decoupled, and 
> encapsulated—you can begin bringing them together into a larger project.
>
> A great example is layout. If you are using a grid system, all of the code 
> pertaining to layout should exist on its own, without including anything else.
> You’ve written code that handles layout, and that's it.
>
> It is important to strike a balance between names that do not literally 
> describe the style that the class brings, but also ones that do not 
> explicitly describe specific use cases. Instead of .home-page-panel, choose 
> .masthead; instead of `.site-nav`, favour `.primary-nav`; instead of 
> `.btn-login`, opt for `.button-primary`.
>
> [CSS Guidelines: The Separation of Concerns](http://cssguidelin.es/#the-separation-of-concerns)

### <a name="css-frameworks"></a>CSS frameworks ###
Frameworks such as [Bootstrap](http://getbootstrap.com/), 
[Zurb Foundation](http://foundation.zurb.com/) and others have very different 
naming conventions however the critical point is each can be used 
interchangeably with these guidelines and the developer has the freedom to 
choose the most appropriate components for the problems at hand. As needed, 
SCSS @extend can provide the ability for components to inherit appropriate 
attributes from framework elements.

### Temptation to overuse @extend ###
The SCSS @extend function should be used with care though because sometimes you 
want those classes in your HTML. For example, when you first learn about 
`@extend` it might be tempting to use it with all of your modifier classes like 
so:

    .button {
        /* button styles */
    }

    /* Bad */
    .button--primary {
          @extend .button;
          /* modification styles */
    }

The problem with doing this is you lose the inheritance chain in the HTML. Now 
it’s very difficult to select all button instances with JavaScript.

#### JavaScript ####
 
Separate style from behavior by using dedicated classes for JavaScript 
manipulation rather than relying on classes already in use for CSS. This way, 
we can modify classes for style purposes without fear of breaking JavaScript, 
and vice versa. To make the distinction clear, classes used for JavaScript 
manipulation should be prefixed with 'js-'. These JavaScript hooks must never 
be used for styling purposes. See the section ‘Formatting Class Names’ for more 
information on naming conventions.

Avoid applying inline styles using JavaScript. If the behaviour is describing a 
state change, apply a class name describing the state (e.g. `.is-active`), and 
allow CSS to provide the appearance. Only use inline styles applied via 
JavaScript when the value of the style attributes must be computed at runtime.

#### SMACSS - Scalable and Modular Architecture for CSS ####

The SMACSS system has been used to conceptually categorize CSS rules. Note that 
some SMACSS nomenclature has been changed to avoid confusion with Drupal 
terminology.

##### Base #####

Base rules consist of styling for HTML elements only, such as used in a CSS 
reset or Normalize.css. Base rules should never include class selectors.

To avoid ‘undoing’ styles in components, base styles should reflect the 
simplest possible appearance of each element. For example, the simplest usage 
of the `ul` element may be completely unstyled, removing list markers and 
indents and relying on a component class for other applications.

##### Layout #####

Arrangement of elements on the page, including grid systems.

> Grid systems should be thought of as shelves. They contain content but are not 
> content in themselves. You put up your shelves then fill them with your stuff 
> [i.e. components]. 
> 
> &mdash; Harry Roberts, CSS Guidelines

##### Component (Module) #####

Alias for a SMACSS “module”.  
Reusable, discrete UI elements; components should form the bulk of a system's 
CSS. 

##### State #####

Styles that deal with transient changes to a component’s appearance. Often, 
these are client-side changes that occur as the user interacts with the page, 
such as hovering links or opening a modal dialog. In some cases, states are 
static for the life of the page and are set from the server, such as the active 
element in main navigation. The main ways to style state are:

* Custom classes, often but not always applied via JavaScript. These should be prefixed with `.is-`, e.g. `.is-transitioning`, `.is-open`, `.is-active`, `.is-selected`;
* Pseudo-classes, such as `:hover` and `:checked`;
* HTML attributes with state semantics, such as details[open], e.g. `input[type='submit'][disabled]`;
* Media queries: styles that alter appearance based on the immediate browser environment.

##### Theme #####

Purely visual styling, such as border, box-shadow, colors and backgrounds, font 
properties, etc. Ideally, these should be separated enough from a component’s 
structure to be “swappable”, and omitting these entirely should not break the 
component’s functionality or basic usability.

### <a name="best-practices_5"></a>5. Name Components using design semantics ###

While the HTML5 specification mentions that class names should “describe the 
nature of the content,” there’s no reason for this. HTML elements already 
impart semantics on the content and machines cannot derive content-level 
semantics from class names (with the narrow exception of microformats.)

>Class names should communicate useful information to developers. 
>
> &mdash; Nicolas Gallagher, [About HTML Semantics and Front-End Architecture](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)

Class names used as CSS hooks should reflect design semantics over content 
semantics. In general, they should reflect the intent and purpose of the design 
element they represent.

Note that this does not preclude presentational class names. Grid system 
classes such as `.grid-3`, utility classes such as `.header` and `.footer` (for 
adding whitespace based on a baseline grid) and `.text-center` are all examples 
of presentational classes that represent visual semantics. They are meaningful 
to developers, and highly reusable.

This does not mean going back to classes like `.blue-box`. This is obviously a 
bad class name since it does not reflect the visual meaning, only one very 
surface attribute. It’s useful to ask “why is this a box, and why blue?”. 
Thinking about this, we might realize that this box is actually a version of 
the style used throughout our site for notifications, and this particular shade 
of blue is used for non-urgent notifications:

    .notification {
          /* general styles for all notifications */
    }
    .notification--info {
      /* color adjustments, e.g. blue  */
    }

**Note for core developers**  
Since classes should represent design semantics and Drupal core must be 
design-agnostic, core default markup should be exceedingly cautious about what 
classes are included. This applies especially to the use of presentational 
class names.

**Note for module developers**  
Since modules are responsible for providing the default HTML implementation, 
module developers should make their best effort to find an existing theme hook 
to use and to insert a design-derived class name, possibly one already found in 
core. If the module’s content has no default design, the class name should be 
based on how the content is built; often this can just be the name of the 
odule (e.g. `class="views"`.)

Module developers should ensure that themers can replace/augment any 
module-provided class.

### <a name="best-practices_6"></a>6. Formatting class names ###

The preference is to use a naming convention to make the purpose of the class 
clear and provide enough context to describe what other parts of the system it 
affects.

  * Class names should use **full words** where possible rather than abbreviations. Styles for a button component should use e.g. `class="button"` rather than `class="btn"`
  * Class names for components should always use a **hyphen between words**. Use `class="button-group"` rather than `class="buttongroup"`
     
***
## <a name="components"></a>Components ##

### <a name="component-markup"></a>Pieces of a component ###

    .component {}
    .component--modifier {}
    .component__element {}
    .component.is-state {}
    .component:hover {}
        
### <a name="component-template"></a>Component Template ###

The component template provides a base set of classes to start with that are 
commonly used for complex components. Use them consistently.

    // Component name
    // Description of component.
    //
    // Variants:
    // .component--variant-A | Description of this variant effect, purpose.
    // .component--variant-B | ...

    .component {
    
        &__header
        &__content
        &__footer

        &__list 
        &__item
            &__item:hover
            &__item.is-active
            &__item.is-disabled
            &__item.js-hook
        &__item-link

        &__title
            @media #{$medium-up}
        
        &__image
        &__image-caption

        &__meta
            .item__date
                .component__date
                .component__publication-date                
                .component__author

		&__reveal
            &__reveal.is-hidden
            &__reveal.is-visible
            
        &--variant
    }
    
    
### <a name="component-template"></a>Component Template ###

Components must have a HTML example accompanying them to illustrate the expected
 final output.

    <div class="component">
        <div class="component__header">
            <h2 class="component__title">Heading</h2>
            <div class="component__date">DD/MM/YYYY</div>
        </div>
        <div class="component__content">
            <img src="" alt="" class="component__image" />
            <p>Cake sweet tootsie roll bonbon. Cotton candy brownie apple...</p>
        </div>
        <div class="component__footer">
            <a href="" class="component__link">Enrol now</a>
        </div>
    </div>


## <a name="file-structure"></a>File Structure ##

Rulesets should be grouped into logical files that enforce the separation of 
concerns within the CSS, and can be aggregated efficiently.

    bower_components/
    |- vendor specific
    |
    css/
    |- styles.css       # Compiled CSS
    |
    scss/ 
    | 
    |– base/
    |   |– _typography.scss  # Typography rules 
    |   |– _tables.scss      # Tables 
    |   |– _lists.scss       # Lists
    |   |– _forms.scss       # Forms
    |   ...                  # Etc… 
    | 
    |– components/ 
    |   |– buttons 
    |       |– _buttons.scss  
    |       |– buttons.html  
    |   |– carousel
    |       |– _carousel.scss    # SCSS
    |       |– carousel.tpl.php  # Drupal template
    |       |– carousel.html     # Static example
    |   |– main-menu             # Navigation 
    |   ...                      # Etc…
    |
    |- contrib/
    |   |– drupal/   		 # Drupal specific overrides
    |      |– _primary-tabs.scss     # Drupal override for tab UI
    |      ...                       # Etc…
    | 
    |– global/
    |   |– _colors.scss      # Color variables
    |   |– _variables.scss   # Sass Variables
    |   |– _functions.scss   # Sass Functions 
    |   |– _mixins.scss      # Sass Mixins 
    |   ...                  # Etc… 
    | 
    |– layout/
    |   |– _header.scss      # Header 
    |   |– _footer.scss      # Footer 
    |   |– _page.scss        # Base page structure
    |   ...                  # Etc… 
    |
    |– _init.scss            # ...
    |- bower.js
    `– styles.scss           # primary SCSS file 


## <a name="linting"></a>Linting ##

Common standards in CSS formatting helps to ensure code is written to avoid 
duplication, unnecessary verbosity, and is structured consistently for multiple 
developers to easily comprehend.

* Order CSS attributes alphabetically.
* Each attribute should be on a new line.
* Leave an empty line between selectors.
* Each selector in a comma separated list should be on a new line.
* Indent using 2 spaces.
* Remove unnecessary leading zeros. e.g. `margin: .5rem;` instead of `margin: 0.5rem;`
* Before and After pseudo-elements should use 2 colons. e.g. `.menu::before {}`
* In SCSS, comments should use // rather than /* so they are not compiled.
* Use single quotes rather than double quotes for escaping content and paths. e.g. `content: '';` and `background-image: url('');`
* Where possible, wrap lines at 80 characters to improve readability.
* The last line of every file should be empty.
* Comments should start with a capital letter and end with a full stop.
* When using icons in CSS; add a comment explaining which font library it is from and the icon class name.
* Use SCSS variables for colours.
* Be consistent with colours, e.g. `#fff` instead of `white`.
* Line-height values should be unitless, [REF](https://css-tricks.com/almanac/properties/l/line-height/#article-header-id-0).


## <a name="acknowledgements"></a>Acknowledgements ##

* [Drupal 8 CSS architecture](https://www.drupal.org/node/1887918)

This Drupal 8 architecture consolidates a number of ideas and principles shared 
by prominent authors.

* YANDEX [BEM Methodology](http://bem.info/method/definitions/) 
* John Albin, [Styleguide Driven Development](http://www.slideshare.net/JohnAlbin/styleguide-driven-development), [Managing Complex Projects with Design Components](http://www.slideshare.net/JohnAlbin/managing-design)
* Philip Walton, [CSS Architecture](http://engineering.appfolio.com/2012/11/16/css-architecture)
* Johnathan Snook, [SMACSS](https://smacss.com)
* Nicolas Gallagher, [About HTML semantics and front-end architecture](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)

**Additional influences and resources**

* Nicole Sullivan, [OOCSS](http://www.slideshare.net/stubbornella/object-oriented-css)
* Harry Roberts, [Code Smells in CSS](http://csswizardry.com/2012/11/code-smells-in-css)
* Harry Roberts, [CSS-Guidelines](http://cssguidelin.es)

## <a name="tools"></a>Tools ##

* [CSS Lint](http://csslint.net/) CSS Lint provides basic syntax checking as well as applying a set of rules to the code that look for problematic patterns or signs of inefficiency. The rules are all pluggable, so you can easily write your own or omit ones you don’t want.
* [CSS Specificity Generator](http://jonassebastianohlsson.com/specificity-graph/), note caveats that the tool provides [insight](http://csswizardry.com/2014/10/the-specificity-graph) rather than a literal interpretation on potential issues.

***

## <a name="notes"></a>Notes ##

### <a name="note-frameworks"></a>Frameworks ###

#### Twitter Bootstrap, Zurb Foundation ####
Both Bootstrap and Foundation make partial use of this pattern in its naming of 
components such as nav and button and their associated modifiers. However, they 
don't class elements within components, relying instead on HTML element 
selectors. This has the upside of less page-weight in the HTML at the cost 
tightly coupling components to a specific HTML structure, which can limit a 
components reuse and increase CSS specificity.

#### SMACSS (Scalable Modular Architecture for CSS) ####
SMACSS uses the same pattern as part of the Module chapter, using the term 
**module** instead of component and **sub-class** for modifier. However there 
is no distinction between elements and modifiers in the naming conventions. 
SMACSS has additional naming conventions for dealing with layout and states. 

These points were much debated in the Drupal forums, based on the collision 
with existing terminology. As a matter of personal taste I propose that 
"component" and "modifier" are more legible.

&mdash; [ATEN Design review CEM design pattern](http://atendesigngroup.com/blog/component-element-modifier-design-pattern)

#### <a name="note-file-size"></a>Concerns about file sizes ####

Related to any discussion about modular/scalable CSS is a concern about file 
size and “bloat”.

It is important to compare the size of files after HTTP compression, because 
minified file sizes do not tell the whole story. It suggests that experienced 
CSS developers using pre-processors don’t need to be overly concerned about a 
certain degree of repetition in the compiled CSS because it can lend itself 
well to smaller file sizes after HTTP compression. 
**The benefits of more maintainable CSS code via pre-processors should trump concerns about the aesthetics or size of the raw and minified output CSS.**
 
&mdash; [Nicholas Gallagher, About HTML Semantics and Front End Architecture ](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/#a-note-on-raw-file-size-and-http-compression)
